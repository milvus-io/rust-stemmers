//! Generated from esperanto.sbl by Snowball 3.0.0 - https://snowballstem.org/

#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_mut)]
#![allow(unused_parens)]
#![allow(unused_variables)]
use snowball::SnowballEnv;
use snowball::Among;

static A_0: &'static [Among<Context>; 17] = &[
    Among("", -1, 14, None),
    Among("-", 0, 13, None),
    Among("cx", 0, 1, None),
    Among("gx", 0, 2, None),
    Among("hx", 0, 3, None),
    Among("jx", 0, 4, None),
    Among("q", 0, 12, None),
    Among("sx", 0, 5, None),
    Among("ux", 0, 6, None),
    Among("w", 0, 12, None),
    Among("x", 0, 12, None),
    Among("y", 0, 12, None),
    Among("á", 0, 7, None),
    Among("é", 0, 8, None),
    Among("í", 0, 9, None),
    Among("ó", 0, 10, None),
    Among("ú", 0, 11, None),
];

static A_1: &'static [Among<Context>; 6] = &[
    Among("as", -1, -1, None),
    Among("i", -1, -1, None),
    Among("is", 1, -1, None),
    Among("os", -1, -1, None),
    Among("u", -1, -1, None),
    Among("us", 4, -1, None),
];

static A_2: &'static [Among<Context>; 17] = &[
    Among("ci", -1, -1, None),
    Among("gi", -1, -1, None),
    Among("hi", -1, -1, None),
    Among("li", -1, -1, None),
    Among("ili", 3, -1, None),
    Among("ŝli", 3, -1, None),
    Among("mi", -1, -1, None),
    Among("ni", -1, -1, None),
    Among("oni", 7, -1, None),
    Among("ri", -1, -1, None),
    Among("si", -1, -1, None),
    Among("vi", -1, -1, None),
    Among("ivi", 11, -1, None),
    Among("ĝi", -1, -1, None),
    Among("ŝi", -1, -1, None),
    Among("iŝi", 14, -1, None),
    Among("malŝi", 14, -1, None),
];

static A_3: &'static [Among<Context>; 20] = &[
    Among("amb", -1, -1, None),
    Among("bald", -1, -1, None),
    Among("malbald", 1, -1, None),
    Among("morg", -1, -1, None),
    Among("postmorg", 3, -1, None),
    Among("adi", -1, -1, None),
    Among("hodi", -1, -1, None),
    Among("ank", -1, -1, None),
    Among("ĉirk", -1, -1, None),
    Among("tutĉirk", 8, -1, None),
    Among("presk", -1, -1, None),
    Among("almen", -1, -1, None),
    Among("apen", -1, -1, None),
    Among("hier", -1, -1, None),
    Among("antaŭhier", 13, -1, None),
    Among("malgr", -1, -1, None),
    Among("ankor", -1, -1, None),
    Among("kontr", -1, -1, None),
    Among("anstat", -1, -1, None),
    Among("kvaz", -1, -1, None),
];

static A_4: &'static [Among<Context>; 2] = &[
    Among("aliu", -1, -1, None),
    Among("unu", -1, -1, None),
];

static A_5: &'static [Among<Context>; 24] = &[
    Among("aha", -1, -1, None),
    Among("haha", 0, -1, None),
    Among("haleluja", -1, -1, None),
    Among("hola", -1, -1, None),
    Among("hosana", -1, -1, None),
    Among("maltra", -1, -1, None),
    Among("hura", -1, -1, None),
    Among("ĥaĥa", -1, -1, None),
    Among("ekde", -1, -1, None),
    Among("elde", -1, -1, None),
    Among("disde", -1, -1, None),
    Among("ehe", -1, -1, None),
    Among("maltre", -1, -1, None),
    Among("dirlididi", -1, -1, None),
    Among("malpli", -1, -1, None),
    Among("malĉi", -1, -1, None),
    Among("malkaj", -1, -1, None),
    Among("amen", -1, -1, None),
    Among("tamen", 17, -1, None),
    Among("oho", -1, -1, None),
    Among("maltro", -1, -1, None),
    Among("minus", -1, -1, None),
    Among("uhu", -1, -1, None),
    Among("muu", -1, -1, None),
];

static A_6: &'static [Among<Context>; 3] = &[
    Among("tri", -1, -1, None),
    Among("du", -1, -1, None),
    Among("unu", -1, -1, None),
];

static A_7: &'static [Among<Context>; 2] = &[
    Among("dek", -1, -1, None),
    Among("cent", -1, -1, None),
];

static A_8: &'static [Among<Context>; 7] = &[
    Among("k", -1, -1, None),
    Among("kelk", 0, -1, None),
    Among("nen", -1, -1, None),
    Among("t", -1, -1, None),
    Among("mult", 3, -1, None),
    Among("samt", 3, -1, None),
    Among("ĉ", -1, -1, None),
];

static A_9: &'static [Among<Context>; 19] = &[
    Among("a", -1, -1, None),
    Among("e", -1, -1, None),
    Among("i", -1, -1, None),
    Among("j", -1, -1, Some(&r_not_after_letter)),
    Among("aj", 3, -1, None),
    Among("oj", 3, -1, None),
    Among("n", -1, -1, Some(&r_not_after_letter)),
    Among("an", 6, -1, None),
    Among("en", 6, -1, None),
    Among("jn", 6, -1, Some(&r_not_after_letter)),
    Among("ajn", 9, -1, None),
    Among("ojn", 9, -1, None),
    Among("on", 6, -1, None),
    Among("o", -1, -1, None),
    Among("as", -1, -1, None),
    Among("is", -1, -1, None),
    Among("os", -1, -1, None),
    Among("us", -1, -1, None),
    Among("u", -1, -1, None),
];

static G_vowel: &'static [u8; 3] = &[17, 65, 16];

static G_aou: &'static [u8; 3] = &[1, 64, 16];

static G_digit: &'static [u8; 2] = &[255, 3];

#[derive(Clone)]
struct Context {
    b_foreign: bool,
}

fn r_canonical_form(env: &mut SnowballEnv, context: &mut Context) -> bool {
    let mut among_var;
    context.b_foreign = false;
    'replab0: loop{
        let v_1 = env.cursor;
        'lab1: for _ in 0..1 {
            env.bra = env.cursor;
            among_var = env.find_among(A_0, context);
            env.ket = env.cursor;
            match among_var {
                1 => {
                    if !env.slice_from("ĉ") {
                        return false;
                    }
                }
                2 => {
                    if !env.slice_from("ĝ") {
                        return false;
                    }
                }
                3 => {
                    if !env.slice_from("ĥ") {
                        return false;
                    }
                }
                4 => {
                    if !env.slice_from("ĵ") {
                        return false;
                    }
                }
                5 => {
                    if !env.slice_from("ŝ") {
                        return false;
                    }
                }
                6 => {
                    if !env.slice_from("ŭ") {
                        return false;
                    }
                }
                7 => {
                    if !env.slice_from("a") {
                        return false;
                    }
                    context.b_foreign = true;
                }
                8 => {
                    if !env.slice_from("e") {
                        return false;
                    }
                    context.b_foreign = true;
                }
                9 => {
                    if !env.slice_from("i") {
                        return false;
                    }
                    context.b_foreign = true;
                }
                10 => {
                    if !env.slice_from("o") {
                        return false;
                    }
                    context.b_foreign = true;
                }
                11 => {
                    if !env.slice_from("u") {
                        return false;
                    }
                    context.b_foreign = true;
                }
                12 => {
                    context.b_foreign = true;
                }
                13 => {
                    context.b_foreign = false;
                }
                14 => {
                    if env.cursor >= env.limit {
                        break 'lab1;
                    }
                    env.next_char();
                }
                _ => ()
            }
            continue 'replab0;
        }
        env.cursor = v_1;
        break 'replab0;
    }
    return !context.b_foreign;
}

fn r_initial_apostrophe(env: &mut SnowballEnv, context: &mut Context) -> bool {
    env.bra = env.cursor;
    if !env.eq_s(&"'") {
        return false;
    }
    env.ket = env.cursor;
    if !env.eq_s(&"st") {
        return false;
    }
    if (env.cursor >= env.limit || env.current.as_bytes()[(env.cursor + 0) as usize] as u8 >> 5 != 3 as u8 || ((2130434 as i32 >> (env.current.as_bytes()[(env.cursor + 0) as usize] as u8 & 0x1f)) & 1) == 0) {
        return false;
    }

    if env.find_among(A_1, context) == 0 {
        return false;
    }
    if env.cursor < env.limit {
        return false;
    }
    if !env.slice_from("e") {
        return false;
    }
    return true
}

fn r_pronoun(env: &mut SnowballEnv, context: &mut Context) -> bool {
    env.ket = env.cursor;
    let v_1 = env.limit - env.cursor;
    'lab0: loop {
        if !env.eq_s_b(&"n") {
            env.cursor = env.limit - v_1;
            break 'lab0;
        }
        break 'lab0;
    }
    env.bra = env.cursor;
    if (env.cursor - 1 <= env.limit_backward || env.current.as_bytes()[(env.cursor - 1) as usize] as u8 != 105 as u8) {
        return false;
    }

    if env.find_among_b(A_2, context) == 0 {
        return false;
    }
    'lab1: loop {
        let v_2 = env.limit - env.cursor;
        'lab2: loop {
            if env.cursor > env.limit_backward {
                break 'lab2;
            }
            break 'lab1;
        }
        env.cursor = env.limit - v_2;
        if !env.eq_s_b(&"-") {
            return false;
        }
        break 'lab1;
    }
    if !env.slice_del() {
        return false;
    }
    return true
}

fn r_final_apostrophe(env: &mut SnowballEnv, context: &mut Context) -> bool {
    env.ket = env.cursor;
    if !env.eq_s_b(&"'") {
        return false;
    }
    env.bra = env.cursor;
    'lab0: loop {
        let v_1 = env.limit - env.cursor;
        'lab1: loop {
            if !env.eq_s_b(&"l") {
                break 'lab1;
            }
            if env.cursor > env.limit_backward {
                break 'lab1;
            }
            if !env.slice_from("a") {
                return false;
            }
            break 'lab0;
        }
        env.cursor = env.limit - v_1;
        'lab2: loop {
            if !env.eq_s_b(&"un") {
                break 'lab2;
            }
            if env.cursor > env.limit_backward {
                break 'lab2;
            }
            if !env.slice_from("u") {
                return false;
            }
            break 'lab0;
        }
        env.cursor = env.limit - v_1;
        'lab3: loop {
            if (env.cursor - 2 <= env.limit_backward || env.current.as_bytes()[(env.cursor - 1) as usize] as u8 >> 5 != 3 as u8 || ((68438676 as i32 >> (env.current.as_bytes()[(env.cursor - 1) as usize] as u8 & 0x1f)) & 1) == 0) {
                break 'lab3;
            }

            if env.find_among_b(A_3, context) == 0 {
                break 'lab3;
            }
            'lab4: loop {
                let v_2 = env.limit - env.cursor;
                'lab5: loop {
                    if env.cursor > env.limit_backward {
                        break 'lab5;
                    }
                    break 'lab4;
                }
                env.cursor = env.limit - v_2;
                if !env.eq_s_b(&"-") {
                    break 'lab3;
                }
                break 'lab4;
            }
            if !env.slice_from("aŭ") {
                return false;
            }
            break 'lab0;
        }
        env.cursor = env.limit - v_1;
        if !env.slice_from("o") {
            return false;
        }
        break 'lab0;
    }
    return true
}

fn r_ujn_suffix(env: &mut SnowballEnv, context: &mut Context) -> bool {
    env.ket = env.cursor;
    let v_1 = env.limit - env.cursor;
    'lab0: loop {
        if !env.eq_s_b(&"n") {
            env.cursor = env.limit - v_1;
            break 'lab0;
        }
        break 'lab0;
    }
    let v_2 = env.limit - env.cursor;
    'lab1: loop {
        if !env.eq_s_b(&"j") {
            env.cursor = env.limit - v_2;
            break 'lab1;
        }
        break 'lab1;
    }
    env.bra = env.cursor;
    if (env.cursor - 2 <= env.limit_backward || env.current.as_bytes()[(env.cursor - 1) as usize] as u8 != 117 as u8) {
        return false;
    }

    if env.find_among_b(A_4, context) == 0 {
        return false;
    }
    'lab2: loop {
        let v_3 = env.limit - env.cursor;
        'lab3: loop {
            if env.cursor > env.limit_backward {
                break 'lab3;
            }
            break 'lab2;
        }
        env.cursor = env.limit - v_3;
        if !env.eq_s_b(&"-") {
            return false;
        }
        break 'lab2;
    }
    if !env.slice_del() {
        return false;
    }
    return true
}

fn r_uninflected(env: &mut SnowballEnv, context: &mut Context) -> bool {
    if (env.cursor - 2 <= env.limit_backward || env.current.as_bytes()[(env.cursor - 1) as usize] as u8 >> 5 != 3 as u8 || ((2672162 as i32 >> (env.current.as_bytes()[(env.cursor - 1) as usize] as u8 & 0x1f)) & 1) == 0) {
        return false;
    }

    if env.find_among_b(A_5, context) == 0 {
        return false;
    }
    'lab0: loop {
        let v_1 = env.limit - env.cursor;
        'lab1: loop {
            if env.cursor > env.limit_backward {
                break 'lab1;
            }
            break 'lab0;
        }
        env.cursor = env.limit - v_1;
        if !env.eq_s_b(&"-") {
            return false;
        }
        break 'lab0;
    }
    return true
}

fn r_merged_numeral(env: &mut SnowballEnv, context: &mut Context) -> bool {
    if (env.cursor - 1 <= env.limit_backward || (env.current.as_bytes()[(env.cursor - 1) as usize] as u8 != 105 as u8 && env.current.as_bytes()[(env.cursor - 1) as usize] as u8 != 117 as u8)) {
        return false;
    }

    if env.find_among_b(A_6, context) == 0 {
        return false;
    }
    if (env.cursor - 2 <= env.limit_backward || (env.current.as_bytes()[(env.cursor - 1) as usize] as u8 != 107 as u8 && env.current.as_bytes()[(env.cursor - 1) as usize] as u8 != 116 as u8)) {
        return false;
    }

    return env.find_among_b(A_7, context) != 0;
}

fn r_correlative(env: &mut SnowballEnv, context: &mut Context) -> bool {
    env.ket = env.cursor;
    env.bra = env.cursor;
    let v_1 = env.limit - env.cursor;
    'lab0: loop {
        let v_2 = env.limit - env.cursor;
        'lab1: loop {
            let v_3 = env.limit - env.cursor;
            'lab2: loop {
                if !env.eq_s_b(&"n") {
                    env.cursor = env.limit - v_3;
                    break 'lab2;
                }
                break 'lab2;
            }
            env.bra = env.cursor;
            if !env.eq_s_b(&"e") {
                break 'lab1;
            }
            break 'lab0;
        }
        env.cursor = env.limit - v_2;
        let v_4 = env.limit - env.cursor;
        'lab3: loop {
            if !env.eq_s_b(&"n") {
                env.cursor = env.limit - v_4;
                break 'lab3;
            }
            break 'lab3;
        }
        let v_5 = env.limit - env.cursor;
        'lab4: loop {
            if !env.eq_s_b(&"j") {
                env.cursor = env.limit - v_5;
                break 'lab4;
            }
            break 'lab4;
        }
        env.bra = env.cursor;
        if !env.in_grouping_b(G_aou, 97, 117) {
            return false;
        }
        break 'lab0;
    }
    if !env.eq_s_b(&"i") {
        return false;
    }
    let v_6 = env.limit - env.cursor;
    'lab5: loop {
        if env.find_among_b(A_8, context) == 0 {
            env.cursor = env.limit - v_6;
            break 'lab5;
        }
        break 'lab5;
    }
    'lab6: loop {
        let v_7 = env.limit - env.cursor;
        'lab7: loop {
            if env.cursor > env.limit_backward {
                break 'lab7;
            }
            break 'lab6;
        }
        env.cursor = env.limit - v_7;
        if !env.eq_s_b(&"-") {
            return false;
        }
        break 'lab6;
    }
    env.cursor = env.limit - v_1;
    if !env.slice_del() {
        return false;
    }
    return true
}

fn r_long_word(env: &mut SnowballEnv, context: &mut Context) -> bool {
    'lab0: loop {
        let v_1 = env.limit - env.cursor;
        'lab1: loop {
            for _ in 0..2 {
                if !env.go_out_grouping_b(G_vowel, 97, 117) {
                    break 'lab1;
                }
env.previous_char();            }
            break 'lab0;
        }
        env.cursor = env.limit - v_1;
        'lab2: loop {
            'golab3: loop {
                'lab4: loop {
                    if !env.eq_s_b(&"-") {
                        break 'lab4;
                    }
                    break 'golab3;
                }
                if env.cursor <= env.limit_backward {
                    break 'lab2;
                }
                env.previous_char();
            }
            if env.cursor <= env.limit_backward {
                break 'lab2;
            }
            env.previous_char();
            break 'lab0;
        }
        env.cursor = env.limit - v_1;
        if !env.go_out_grouping_b(G_digit, 48, 57) {
            return false;
        }
env.previous_char();        break 'lab0;
    }
    return true
}

fn r_not_after_letter(env: &mut SnowballEnv, context: &mut Context) -> bool {
    'lab0: loop {
        let v_1 = env.limit - env.cursor;
        'lab1: loop {
            if !env.eq_s_b(&"-") {
                break 'lab1;
            }
            break 'lab0;
        }
        env.cursor = env.limit - v_1;
        if !env.in_grouping_b(G_digit, 48, 57) {
            return false;
        }
        break 'lab0;
    }
    return true
}

fn r_standard_suffix(env: &mut SnowballEnv, context: &mut Context) -> bool {
    env.ket = env.cursor;
    if (env.cursor <= env.limit_backward || env.current.as_bytes()[(env.cursor - 1) as usize] as u8 >> 5 != 3 as u8 || ((2672162 as i32 >> (env.current.as_bytes()[(env.cursor - 1) as usize] as u8 & 0x1f)) & 1) == 0) {
        return false;
    }

    if env.find_among_b(A_9, context) == 0 {
        return false;
    }
    let v_1 = env.limit - env.cursor;
    'lab0: loop {
        if !env.eq_s_b(&"-") {
            env.cursor = env.limit - v_1;
            break 'lab0;
        }
        break 'lab0;
    }
    env.bra = env.cursor;
    if !env.slice_del() {
        return false;
    }
    return true
}

pub fn stem(env: &mut SnowballEnv) -> bool {
    let mut context = &mut Context {
        b_foreign: false,
    };
    let v_1 = env.cursor;
    if !r_canonical_form(env, context) {
        return false;
    }
    env.cursor = v_1;
    let v_2 = env.cursor;
    r_initial_apostrophe(env, context);
    env.cursor = v_2;
    env.limit_backward = env.cursor;
    env.cursor = env.limit;
    let v_3 = env.limit - env.cursor;
    'lab0: loop {
        if !r_pronoun(env, context) {
            break 'lab0;
        }
        return false;
    }
    env.cursor = env.limit - v_3;
    let v_4 = env.limit - env.cursor;
    r_final_apostrophe(env, context);
    env.cursor = env.limit - v_4;
    let v_5 = env.limit - env.cursor;
    'lab1: loop {
        if !r_correlative(env, context) {
            break 'lab1;
        }
        return false;
    }
    env.cursor = env.limit - v_5;
    let v_6 = env.limit - env.cursor;
    'lab2: loop {
        if !r_uninflected(env, context) {
            break 'lab2;
        }
        return false;
    }
    env.cursor = env.limit - v_6;
    let v_7 = env.limit - env.cursor;
    'lab3: loop {
        if !r_merged_numeral(env, context) {
            break 'lab3;
        }
        return false;
    }
    env.cursor = env.limit - v_7;
    let v_8 = env.limit - env.cursor;
    'lab4: loop {
        if !r_ujn_suffix(env, context) {
            break 'lab4;
        }
        return false;
    }
    env.cursor = env.limit - v_8;
    let v_9 = env.limit - env.cursor;
    if !r_long_word(env, context) {
        return false;
    }
    env.cursor = env.limit - v_9;
    if !r_standard_suffix(env, context) {
        return false;
    }
    env.cursor = env.limit_backward;
    return true
}
